<html>
  <head>
    <meta charset="utf-8">
    <title>istSOS Chart Component</title>
    <!-- <script src="../bower_components/webcomponentsjs/webcomponents.min.js"></script> -->
    <script src="../bower_components/javascript-core/compiled/istsos-core-2.0.js"></script>
    <script src="//d3js.org./d3.v3.min.js"></script>
    <script src="//vega.github.io/vega/vega.js"></script>
    <script src="//vega.github.io/vega-lite/vega-lite.js"></script>
    <script src="//vega.github.io/vega-editor/vendor/vega-embed.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.13.0/moment.min.js"></script> 
    <script src="data/data-provider.js"></script> 
    <script src="util/util.js"></script>
    <style>
      .tooltip {
        width: 100%;
        display: block;
      }
      .vega-actions a {
        margin-right: 5px;
      }
    </style>
  </head>
  <body>
    <script>
      $.ajaxSetup({ async: true });

      // Define and register HTML element <istsos-chart>
      var proto = Object.create(HTMLElement.prototype);
       
      proto.createdCallback = function() {
        var jsonSpec = {};
        var measurements = [];
        var uoms = new Object();
        var vegaMode = "vega";

        // Mandatory parameters
        var server = this.getAttribute("server");
        var service = this.getAttribute("service");
        var offering = this.getAttribute("offering");
        
        // Validation of mandatory parameter properties.
        var procedures = null;
        try {
          procedures = this.getAttribute("procedures").replace(/ /g, "").split(",");
          if (procedures.indexOf("") > -1) { 
            procedures = null;
            throw new Error("Empty strings are not allowed as procedure names."); 
          }
        } catch(e) {
          console.log(e);
        }


        // Validation of mandatory parameter properties.
        var props = null;
        try {
          props = this.getAttribute("property").toLowerCase().replace(/ /g, "").split(",");
          if (props.indexOf("") > -1) { 
            props = null;
            throw new Error("Empty strings are not allowed as observed property values."); 
          }
        } catch(e) {
          console.log(e);
        }
        var from = this.getAttribute("from");
        var until = this.getAttribute("until");

        // If mandatory parameters are not present, don't execute chart generation
        if (server == null || service == null || offering == null || procedures == null || props == null || from == null || until == null) {
          console.log("Please specify all the mandatory parameters.")
        } else {
          // Instantiating not mandatory parameters with default values.
          var chartType = this.getAttribute("type") || "line";
          var height = parseInt(this.getAttribute("height")) || 250;
          var width = parseInt(this.getAttribute("width")) || 500;
          var color = this.getAttribute("color") || "#0072BB";
          var color2 = this.getAttribute("color2") || "#FF4C3B";
          var strokeWidth = parseInt(this.getAttribute("strokeWidth")) || 1;
          var aggregateFunction = this.getAttribute("aggregateFunction") || "average";
          var aggregateInterval = this.getAttribute("aggregateInterval") || "month";



          // Time unit parameter applied when line, bar, punch-card or scatterplot chart is selected
          var timeUnit = this.getAttribute("timeUnit") || "month";
          // Second time unit parameter. Only applied when punch-card chart is selected
          var timeUnit2 = this.getAttribute("timeUnit2") || "hours";
          // Time format to apply when multivariable chart is selected
          var timeFormat = this.getAttribute("timeFormat") || "";
          // The next set of parameters are applied only to trellis charts
          var rowTimeUnit = this.getAttribute("rowTimeUnit") || "year";
          var xTimeUnit = this.getAttribute("xTimeUnit") || "month";
          var yTimeUnit = this.getAttribute("yTimeUnit") || "hours";
          var bin = this.getAttribute("bin") == "true" ? true : false;

          var divId = this.getAttribute("divId");

          if (moment.utc(from).isValid() && moment.utc(until).isValid()) {
            // Get observations with the set of mandatory parameters using the script called data-provider.
            // The callback function loadSpec is passed as a parameter in order to execute the chart specification loading
            // after the successful execution of the function getObservations.
            getObservations(server, service, offering, procedures, props, from, until, loadSpec);
          }

          function loadSpec(data, units) {
            measurements = data;
            uoms = units;
        
            if (chartType == "histogram") {
              if (procedures.length > 1) {
                chartType = "multiple-bar-histogram";
                getJSONSpec("default-multiple-bar-histogram-spec", embedChart);
              } else {
                chartType = "single-bar-histogram";
                getJSONSpec("default-single-bar-histogram-spec", embedChart);
              }
            } else if (chartType == "overview-detail") {
              getJSONSpec("default-overview-detail-spec", embedChart);
            } else if (chartType == "multivariable") {
              getJSONSpec("default-multivariable-spec", embedChart);
            }
          }

          function embedChart(jsonSpec) { 
            if (chartType == "overview-detail") {

              var sfrom = moment(from).format("MMM d YYYY");
              var suntil = moment(until).format("MMM d YYYY");

              jsonSpec.data[0].values = measurements;
              var propertyName = props[0];
              jsonSpec.data[0].format.parse[propertyName] = jsonSpec.data[0].format.parse["measurement"];
              delete jsonSpec.data[0].format.parse["measurement"];

              jsonSpec.scales[1].domain.field = propertyName;
              jsonSpec.scales[3].domain.field = propertyName;
              jsonSpec.marks[0].axes[1].title = propertyName + "(" + uoms[propertyName] + ")";
              jsonSpec.marks[0].marks[0].marks[0].properties.update.y.field = propertyName;
              jsonSpec.marks[1].marks[0].properties.update.y.field = propertyName;

              jsonSpec.signals[1].init.expr = "datetime('" + sfrom + "')";
              jsonSpec.signals[2].init.expr = "datetime('" + sfrom + "')";
              jsonSpec.signals[2].expr = "time(brush_start) === time(brush_end) ? datetime('" + sfrom + "') : min(brush_start, brush_end)";
              jsonSpec.signals[3].init.expr = "datetime('" + suntil + "')";
              jsonSpec.signals[3].expr = "time(brush_start) === time(brush_end) ? datetime('" + suntil + "') : max(brush_start, brush_end)";

              jsonSpec.marks[0].marks[0].marks[0].properties.update.fill.value = color;
              jsonSpec.marks[1].marks[0].properties.update.fill.value = color2;
            } else if (chartType == "multivariable") {
              // Asigning data to chart specification.
              jsonSpec.data[0].values = measurements;
   
              // Initializing size of the chart
              jsonSpec["height"] = height;
              jsonSpec["width"] = width;

              var property1 = props[0];
              var property2 = props[1];
              
              // Initializing format of observed properties.
              jsonSpec.data[0].format.parse[property1] = "number";
              jsonSpec.data[0].format.parse[property2] = "number";
              
              // Modifying scales configuration with observed properties.
              jsonSpec.scales[2].domain.field = property1;
              jsonSpec.scales[3].domain.field = property2;

              // Initializing axes titles.
              jsonSpec.axes[1].title = property1 + "(" + uoms[property1] + ")";
              jsonSpec.axes[2].title = property2 + "(" + uoms[property2] + ")";

              // Modification of marks configuration //
              // Line configuration.
              jsonSpec.marks[0].marks[0].properties.enter.y.field = property1;
              jsonSpec.marks[0].marks[0].properties.enter.y2.field = property2;
              // Symbol (circle mark) configuration.
              jsonSpec.marks[0].marks[1].properties.enter.y.field = property1;
              jsonSpec.marks[0].marks[1].properties.enter.y2.field = property2;
              // Tooltip configuration.
              jsonSpec.marks[0].marks[2].properties.update.y.signal = "tooltip." + property1;
              jsonSpec.marks[0].marks[2].marks[0].properties.update.text.signal = "tooltip." + property1;
              jsonSpec.marks[0].marks[2].marks[1].properties.update.text.signal = "tooltip." + property2;
            
            } else if (chartType == "single-bar-histogram") {            
              // Asigning data to chart specification.
              jsonSpec.data[0].values = measurements;

              // Initializing size of the chart
              jsonSpec["height"] = height;
              jsonSpec["width"] = width;
             
              // Create array containing the name of the fields used for the group by operation.
              var groupby = ["symbol", aggregateInterval];
              // Observed property passed as parameter by the user.
              var propertyName = props[0];
              
              jsonSpec.data[0].transform[0].groupby = groupby;
              jsonSpec.data[0].transform[0].summarize[0].field = propertyName;
              jsonSpec.data[0].transform[0].summarize[0].ops = [aggregateFunction];
            
              jsonSpec.scales[0].domain["field"] = aggregateInterval;
              // Legend color.
              jsonSpec.scales[2].range = [color];

              jsonSpec.axes[1].title =  propertyName + "(" + uoms[propertyName] + ")" + " - " + aggregateFunction;

              // Configuration of tooltips showing the observation value when the cursor hover on the bars.
              jsonSpec.marks[0].properties.enter.x["field"] = aggregateInterval;
              jsonSpec.marks[1].properties.update.x["signal"] = "tooltip." + aggregateInterval;
              
              // Configuration of color for bar and for hover effect.
              jsonSpec.marks[0].properties.update.fill[1].value = color;
              jsonSpec.marks[0].properties.update.fill[0].value = color2;
            } else if (chartType == "multiple-bar-histogram") {
              jsonSpec["height"] = height;
              jsonSpec["width"] = width;
              jsonSpec.data[0].values = measurements;

              // Create array containing the name of the fields used for the group by operation.
              var groupby = ["symbol", aggregateInterval];
              // Observed property passed as parameter by the user.
              var propertyName = props[0];
              
              jsonSpec.data[0].transform[0].groupby = groupby;
              jsonSpec.data[0].transform[0].summarize[0].field = propertyName;
              jsonSpec.data[0].transform[0].summarize[0].ops = [aggregateFunction];

              jsonSpec.scales[0].domain["field"] = aggregateInterval;
              
              jsonSpec.axes[1].title =  propertyName + "(" + uoms[propertyName] + ")" + " - " + aggregateFunction;

              jsonSpec.marks[0].marks[0].from.transform[0].groupby = [aggregateInterval];
              jsonSpec.marks[0].marks[0].marks[1].properties.update.fillOpacity[0].test = "tooltip." + aggregateInterval + "!=" + "datum." + aggregateInterval;
              
            }
          
            var embedSpec = { mode: vegaMode, spec: jsonSpec };
            vg.embed("#" + divId, embedSpec, function(error, result) { });
          }
        }
      };

      document.registerElement("istsos-chart", {prototype: proto});
    </script>
  </body>
</html>
